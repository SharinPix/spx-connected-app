import { SfCommand, Flags } from '@salesforce/sf-plugins-core';
import { Messages, AuthInfo, Connection, Org } from '@salesforce/core';
// import { result } from 'lodash';

Messages.importMessagesDirectory(__dirname);
const messages = Messages.loadMessages('@sharinpix/spx-connected-app', 'connected.create');

export type CreateResult = { fullName: string; success: boolean }

export default class ConnectedAppCreate extends SfCommand<CreateResult> {
  public static readonly summary = messages.getMessage('summary');
  public static readonly description = messages.getMessage('description');
  public static readonly examples = messages.getMessages('examples');

  public static readonly flags = {
    name: Flags.string({
      summary: messages.getMessage('flags.name.summary'),
      char: 'n',
      required: false,
    }),
    username: Flags.string({
      summary: messages.getMessage('flags.username.summary'),
      char: 'u',
      required: true,
    }),
    'oauth-callback-url': Flags.string({
      summary: messages.getMessage('flags.oauth-callback-url.summary'),
      char: 'c',
    }),
    email: Flags.string({
      summary: messages.getMessage('flags.email.summary'),
      char: 'e',
    }),
    scopes: Flags.string({
      summary: messages.getMessage('flags.scopes.summary'),
      char: 's',
    }),
    'canvas-url': Flags.string({
      summary: messages.getMessage('flags.canvas-url.summary'),
      char: 'i',
    }),
    accessmethod: Flags.string({
      summary: messages.getMessage('flags.accessmethod.summary'),
      char: 'm',
    }),
    locations: Flags.string({
      summary: messages.getMessage('flags.locations.summary'),
      char: 'f',
    }),
    options: Flags.string({
      summary: messages.getMessage('flags.options.summary'),
      char: 't',
    }),
    namespace: Flags.string({
      summary: messages.getMessage('flags.namespace.summary'),
      char: 'p',
    }),
    consumersecret: Flags.string({
      summary: messages.getMessage('flags.consumersecret.summary'),
      char: 'q',
    }),
  };

  public async run(): Promise<CreateResult> {
    const { flags } = await this.parse(ConnectedAppCreate);

    const username = flags.username;
    const fullName = flags.name;
    const label = (flags.label || fullName) as string;
    const contactEmail = flags.email;
    const callbackUrl = flags['oauth-callback-url'] ?? 'sfdx://success';
    const description = 'Generated by SharinPix';
    const scopes = (flags.scopes as string).split(',') ;
    
    const canvasUrl = flags['canvas-url'] as string;
    const accessMethod = flags.accessmethod;
    const locations: string | undefined = flags.locations;
    const options: string | undefined = flags.options;
    const consumerSecret = flags.consumersecret;
    const namespace = flags.namespace;

    let metadata = {
      contactEmail,
      description,
      fullName,
      label,
      oauthConfig: { callbackUrl, consumerSecret, scopes },
      canvasConfig: {
        canvasUrl,
        accessMethod,
        locations: locations?.split(','),
        options: options?.split(',')
      }
    };

    metadata = this.removeEmpty(metadata);

    const org: Org = await Org.create({ aliasOrUsername: username });
    const authInfo = await AuthInfo.create({ username: org.getUsername() });
    const connection = await Connection.create({ authInfo });
    const results = await connection.metadata.create('ConnectedApp', metadata);

    if (results.success) {
      let connectedAppName = results.fullName
      if (namespace) {
        connectedAppName = `${namespace}__${connectedAppName}`;
      }
      return (await connection.metadata.read('ConnectedApp', connectedAppName)) as unknown as CreateResult;
    }
    
    return results;
  }

  public removeEmpty(obj: any): any {
    return Object.entries(obj)
      .filter(([_, v]) => v != null)
      .reduce(
        (acc, [k, v]) => ({ ...acc, [k]: v === Object(v) ? this.removeEmpty(v) : v }),
        {}
      );
  }
}
